# Chapter35

## 📌문제1. 출력결과물을 예측하세요.

### 문제 작성

```js
const obj1 = { a: 10, b: 2 };
const obj2 = { c: 3, a: 1 };
const merged = { ...obj1, ...obj2 };
console.log(merged); // (1)
```

### 정답 및 해설

```
(1): {a: 1, b:2, c:3}
일반 객체가 이터러블이 아니지만, 객체 리터럴 내부에선 스프레드 문법을 사용할 수 있다.
프로퍼티가 중복되는경우 뒤에 위치한 프로퍼티가 우선권을 갖는다.
```

<br>

## 📌문제2

### 코드 실행 결과를 예측히세요.

```js
const arr = [2, 3, 4];

const max1 = Math.max(arr); // (1)
const max2 = Math.max(1, 2, 3, 4); // (2)
const max3 = Math.max([1, 2, 3, 4]); // (3)
const max4 = Math.max.apply(null, arr); // (4)
const max5 = Math.max(...arr); // (5)
```

### 답안 작성

```
(1) : NaN
(2) : 4
(3) : NaN
(4) : 4
(5) : 4
```

```
(1), (2), (3) : Math.max 메서드에 숫자가 아닌 배열을 인수로 전달하면 최대값을 구할 수 없으므로 NaN을 반환합니다.
(4) : apply 함수의 두 번째 인수는 apply 함수가 호출하는 함수의 인수 목록입니다. 따라서 배열이 펼쳐져서 인수로 전달됩니다.
(5) : 스프레드 문법을 사용하여 배열을 펼쳐서 전달합니다. Math.max(...[2,3,4])는 Math.max(2,3,4)와 같습니다.
```

<br>

## 📌문제3

### 다음 코드의 실행 결과를 예측히세요.

```js
const merged = { ...{ a: 1, b: 2, c: 0 }, ...{ b: 100, d: 3 } };
console.log(merged); // (1)

const changed = { ...{ a: 1, b: 2 }, b: 100 };
console.log(changed); // (2)

const added = { ...{ a: 1, b: 2 }, c: 0 };
console.log(added); // (3)
```

### 답안 작성

```
(1) : { a: 1, b: 10, c: 0, d: 3 }
(2) : { a: 1, b: 100 }
(3) : { a: 1, b: 2, c: 0 }
```

```
(1) : 프로퍼티가 중복되는 경우, 뒤에 위치한 프로퍼티가 우선권을 갖습니다.
(2) : const changed = { ...{ a: 1, b: 2 }, ...{ b: 100 } };
(3) : const added = { ...{ a: 1, b: 2 }, ...{ c: 0 } };
```

<br>
